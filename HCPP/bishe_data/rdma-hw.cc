#include <ns3/simulator.h>
#include <ns3/seq-ts-header.h>
#include <ns3/udp-header.h>
#include <ns3/ipv4-header.h>
#include "ns3/ppp-header.h"
#include "ns3/boolean.h"
#include "ns3/uinteger.h"
#include "ns3/double.h"
#include "ns3/data-rate.h"
#include "ns3/pointer.h"
#include "rdma-hw.h"
#include "ppp-header.h"
#include "qbb-header.h"
#include "cn-header.h"

namespace ns3{

TypeId RdmaHw::GetTypeId (void)
{
	static TypeId tid = TypeId ("ns3::RdmaHw")
		.SetParent<Object> ()
		.AddAttribute("MinRate",
				"Minimum rate of a throttled flow",
				DataRateValue(DataRate("100Mb/s")),
				MakeDataRateAccessor(&RdmaHw::m_minRate),
				MakeDataRateChecker())
		.AddAttribute("Mtu",
				"Mtu.",
				UintegerValue(1000),
				MakeUintegerAccessor(&RdmaHw::m_mtu),
				MakeUintegerChecker<uint32_t>())
		.AddAttribute ("CcMode",
				"which mode of DCQCN is running",
				UintegerValue(0),
				MakeUintegerAccessor(&RdmaHw::m_cc_mode),
				MakeUintegerChecker<uint32_t>())
		.AddAttribute("NACK Generation Interval",
				"The NACK Generation interval",
				DoubleValue(500.0),
				MakeDoubleAccessor(&RdmaHw::m_nack_interval),
				MakeDoubleChecker<double>())
		.AddAttribute("L2ChunkSize",
				"Layer 2 chunk size. Disable chunk mode if equals to 0.",
				UintegerValue(0),
				MakeUintegerAccessor(&RdmaHw::m_chunk),
				MakeUintegerChecker<uint32_t>())
		.AddAttribute("L2AckInterval",
				"Layer 2 Ack intervals. Disable ack if equals to 0.",
				UintegerValue(0),
				MakeUintegerAccessor(&RdmaHw::m_ack_interval),
				MakeUintegerChecker<uint32_t>())
		.AddAttribute("L2BackToZero",
				"Layer 2 go back to zero transmission.",
				BooleanValue(false),
				MakeBooleanAccessor(&RdmaHw::m_backto0),
				MakeBooleanChecker())
		.AddAttribute("EwmaGain",
				"Control gain parameter which determines the level of rate decrease",
				DoubleValue(1.0 / 16),
				MakeDoubleAccessor(&RdmaHw::m_g),
				MakeDoubleChecker<double>())
		.AddAttribute ("RateOnFirstCnp",
				"the fraction of rate on first CNP",
				DoubleValue(1.0),
				MakeDoubleAccessor(&RdmaHw::m_rateOnFirstCNP),
				MakeDoubleChecker<double> ())
		.AddAttribute("ClampTargetRate",
				"Clamp target rate.",
				BooleanValue(false),
				MakeBooleanAccessor(&RdmaHw::m_EcnClampTgtRate),
				MakeBooleanChecker())
		.AddAttribute("RPTimer",
				"The rate increase timer at RP in microseconds",
				DoubleValue(1500.0),
				MakeDoubleAccessor(&RdmaHw::m_rpgTimeReset),
				MakeDoubleChecker<double>())
		.AddAttribute("RateDecreaseInterval",
				"The interval of rate decrease check",
				DoubleValue(4.0),
				MakeDoubleAccessor(&RdmaHw::m_rateDecreaseInterval),
				MakeDoubleChecker<double>())
		.AddAttribute("FastRecoveryTimes",
				"The rate increase timer at RP",
				UintegerValue(5),
				MakeUintegerAccessor(&RdmaHw::m_rpgThreshold),
				MakeUintegerChecker<uint32_t>())
		.AddAttribute("AlphaResumInterval",
				"The interval of resuming alpha",
				DoubleValue(55.0),
				MakeDoubleAccessor(&RdmaHw::m_alpha_resume_interval),
				MakeDoubleChecker<double>())
		.AddAttribute("RateAI",
				"Rate increment unit in AI period",
				DataRateValue(DataRate("5Mb/s")),
				MakeDataRateAccessor(&RdmaHw::m_rai),
				MakeDataRateChecker())
		.AddAttribute("RateHAI",
				"Rate increment unit in hyperactive AI period",
				DataRateValue(DataRate("50Mb/s")),
				MakeDataRateAccessor(&RdmaHw::m_rhai),
				MakeDataRateChecker())
		.AddAttribute("VarWin",
				"Use variable window size or not",
				BooleanValue(false),
				MakeBooleanAccessor(&RdmaHw::m_var_win),
				MakeBooleanChecker())
		.AddAttribute("FastReact",
				"Fast React to congestion feedback",
				BooleanValue(true),
				MakeBooleanAccessor(&RdmaHw::m_fast_react),
				MakeBooleanChecker())
		.AddAttribute("MiThresh",
				"Threshold of number of consecutive AI before MI",
				UintegerValue(5),
				MakeUintegerAccessor(&RdmaHw::m_miThresh),
				MakeUintegerChecker<uint32_t>())
		.AddAttribute("TargetUtil",
				"The Target Utilization of the bottleneck bandwidth, by default 95%",
				DoubleValue(0.95),
				MakeDoubleAccessor(&RdmaHw::m_targetUtil),
				MakeDoubleChecker<double>())
		.AddAttribute("UtilHigh",
				"The upper bound of Target Utilization of the bottleneck bandwidth, by default 98%",
				DoubleValue(0.98),
				MakeDoubleAccessor(&RdmaHw::m_utilHigh),
				MakeDoubleChecker<double>())
		.AddAttribute("RateBound",
				"Bound packet sending by rate, for test only",
				BooleanValue(true),
				MakeBooleanAccessor(&RdmaHw::m_rateBound),
				MakeBooleanChecker())
		.AddAttribute("MultiRate",
				"Maintain multiple rates in HPCC",
				BooleanValue(true),
				MakeBooleanAccessor(&RdmaHw::m_multipleRate),
				MakeBooleanChecker())
		.AddAttribute("SampleFeedback",
				"Whether sample feedback or not",
				BooleanValue(false),
				MakeBooleanAccessor(&RdmaHw::m_sampleFeedback),
				MakeBooleanChecker())
		.AddAttribute("TimelyAlpha",
				"Alpha of TIMELY",
				DoubleValue(0.875),
				MakeDoubleAccessor(&RdmaHw::m_tmly_alpha),
				MakeDoubleChecker<double>())
		.AddAttribute("TimelyBeta",
				"Beta of TIMELY",
				DoubleValue(0.8),
				MakeDoubleAccessor(&RdmaHw::m_tmly_beta),
				MakeDoubleChecker<double>())
		.AddAttribute("TimelyTLow",
				"TLow of TIMELY (ns)",
				UintegerValue(50000),
				MakeUintegerAccessor(&RdmaHw::m_tmly_TLow),
				MakeUintegerChecker<uint64_t>())
		.AddAttribute("TimelyTHigh",
				"THigh of TIMELY (ns)",
				UintegerValue(500000),
				MakeUintegerAccessor(&RdmaHw::m_tmly_THigh),
				MakeUintegerChecker<uint64_t>())
		.AddAttribute("TimelyMinRtt",
				"MinRtt of TIMELY (ns)",
				UintegerValue(20000),
				MakeUintegerAccessor(&RdmaHw::m_tmly_minRtt),
				MakeUintegerChecker<uint64_t>())
		.AddAttribute("DctcpRateAI",
				"DCTCP's Rate increment unit in AI period",
				DataRateValue(DataRate("1000Mb/s")),
				MakeDataRateAccessor(&RdmaHw::m_dctcp_rai),
				MakeDataRateChecker())
		.AddAttribute("PintSmplThresh",
				"PINT's sampling threshold in rand()%65536",
				UintegerValue(65536),
				MakeUintegerAccessor(&RdmaHw::pint_smpl_thresh),
				MakeUintegerChecker<uint32_t>())
		;
	return tid;
}

class rtt_pred {
public:

	double rtts = 4176;//rtt_-1的平滑值，每次预测结束后更新
	double a = 0.8;//对上一刻平滑结果的依赖
	double wi[64] = { 0.7314396500587463, 0.60235595703125, 0.6227283477783203, 0.11978758126497269, 0.6532860398292542, 0.5742068290710449, 1.2580198049545288, 1.0600005388259888, 0.11510726064443588, 1.3050706386566162, 0.34038829803466797, 0.570970892906189, 0.6124259829521179, 1.4241397380828857, 1.2672978639602661, 1.1496554613113403, -0.3146619200706482, 0.587833046913147, 0.2910670042037964, 0.6034465432167053, 0.20235733687877655, 0.3775416612625122, 0.7484710216522217, -0.1263560801744461, -1.5280970335006714, -1.0806446075439453, 0.2258877456188202, 0.3896142244338989, 0.5247869491577148, 1.5233941078186035, 0.02142333798110485, 1.0086115598678589, -1.0922794342041016, -0.052922412753105164, 0.5000085234642029, 1.0894869565963745, 0.5723631381988525, -0.7554805874824524, -0.21983541548252106, -0.8970580697059631, 1.723658800125122, -1.7947603464126587, 0.5551685094833374, -0.06702648848295212, 0.7398666143417358, -0.5889083743095398, -1.0347676277160645, -0.26286131143569946, 0.7880085706710815, 0.39215996861457825, 0.33953431248664856, 0.4212198555469513, 0.7504084706306458, 0.8756343126296997, 1.4837321043014526, 0.7723389863967896, 0.3969590663909912, 1.4126977920532227, 0.14027449488639832, 0.7223773002624512, 0.3031487464904785, 1.6942521333694458, 1.2322221994400024, 1.1995302438735962 };
	double wh[64][16] = { {0.14705653488636017, -0.22383427619934082, 0.45041051506996155, 0.5843309164047241, 0.588589608669281, -0.5824158191680908, 0.2094687521457672, -0.23775120079517365, -0.12542487680912018, 0.27063360810279846, 0.2501119077205658, -0.4350999891757965, 0.33008742332458496, 0.6742917895317078, -0.009949659928679466, 0.3714962303638458}, {-0.40989333391189575, -0.5082727670669556, 0.42666733264923096, 0.7708039283752441, 0.5787597894668579, -0.7091035842895508, 0.6789267063140869, -0.3960916996002197, 1.1708234548568726, -1.4214891195297241, 0.1798609048128128, -0.2114722579717636, 0.4638326168060303, -0.4742989242076874, -1.1475589275360107, 0.15636372566223145}, {0.3958982229232788, -0.14735905826091766, -0.1724524348974228, -0.07891494780778885, -0.014663470908999443, 0.06662362813949585, 0.37801969051361084, 0.14490334689617157, -0.24986833333969116, 0.07402367889881134, 0.11713528633117676, -0.20341402292251587, 0.1820816546678543, 0.6638669967651367, 0.1867097169160843, 0.5450495481491089}, {1.694706678390503, -0.7192181944847107, 0.6342154741287231, -0.151881605386734, 0.3254353404045105, -0.06775616109371185, 1.8736568689346313, 0.8223752975463867, -1.5897613763809204, 0.9796009659767151, 0.4135468602180481, -0.8648791313171387, 0.015584751963615417, 1.4188326597213745, 0.8133341073989868, 1.7072805166244507}, {0.24766504764556885, -0.2511385381221771, -0.015744302421808243, -0.358561635017395, -0.20525039732456207, 0.3420678973197937, 0.04677799344062805, 0.4057658612728119, -0.2904912233352661, 0.6075460910797119, -0.07289127260446548, -0.011415068991482258, 0.016027182340621948, 0.4226245880126953, 0.46872276067733765, 0.3993121385574341}, {0.400397390127182, 0.06969315558671951, -0.012965657748281956, -0.553787112236023, 0.17705124616622925, -0.10440754145383835, 0.2165113240480423, 0.09198816865682602, -0.5105717182159424, 0.9076793193817139, -0.044998183846473694, -0.06051803007721901, 0.10183165222406387, 0.964367687702179, 0.7588459849357605, 0.312059223651886}, {0.21780849993228912, -0.16204187273979187, -0.11235356330871582, 0.19796469807624817, 0.10519269853830338, -0.267976313829422, 0.210899218916893, 0.24787144362926483, 0.20064783096313477, -0.19093388319015503, 0.12179061025381088, 0.11490701884031296, -0.02678878977894783, -0.33635854721069336, -0.12624432146549225, -0.11536403000354767}, {0.14219623804092407, -0.8360702991485596, 0.39876964688301086, 1.1121023893356323, 0.7345249056816101, -0.5998014807701111, 0.9797130227088928, -0.20948931574821472, -0.03756989166140556, -0.7975161075592041, 0.39135095477104187, -0.23880994319915771, 0.4421607255935669, 0.5426377654075623, -0.9220711588859558, 0.7591186165809631}, {0.6230145692825317, -0.04183439165353775, 0.22983232140541077, -0.17599424719810486, 0.5227447748184204, -0.040699269622564316, 0.8207129240036011, 0.34324488043785095, -0.7616952657699585, 1.2884035110473633, 0.4151357114315033, -0.520588219165802, 0.27552592754364014, 0.8889561295509338, 0.5554596185684204, 0.8752882480621338}, {1.49427330493927, -0.22767098248004913, 0.7762753963470459, 0.2592463195323944, 0.9187494516372681, -0.037196774035692215, 1.4907149076461792, 1.0811876058578491, -1.226767897605896, 0.42843058705329895, 0.48220908641815186, -0.6767957210540771, 0.4444580376148224, 1.1485086679458618, 0.36389288306236267, 1.6680314540863037}, {0.525166392326355, -0.008769546635448933, -0.19470852613449097, -0.3705575466156006, -0.12851132452487946, 0.027567187324166298, 0.34373950958251953, 0.5008078813552856, -0.48261144757270813, 0.5228341817855835, 0.13663196563720703, 0.09773752093315125, 0.05227712169289589, 0.24025140702724457, 0.30084460973739624, 0.3477027714252472}, {0.4030352234840393, -0.21526092290878296, 0.08133281022310257, -0.1581379622220993, 0.21109561622142792, 0.11396723985671997, 0.17659097909927368, 0.3861265182495117, -0.28610143065452576, 0.42627599835395813, 0.08997997641563416, -0.15814891457557678, -0.32239821553230286, 0.42608314752578735, 0.21749113500118256, -0.035257190465927124}, {0.6184751987457275, -0.11266504973173141, 0.05496061220765114, -0.029310274869203568, 0.12413792312145233, -0.03215440735220909, 0.040977220982313156, 0.04799255356192589, -0.6440275311470032, 0.5597360730171204, -0.11538887023925781, -0.21510691940784454, -0.010135488584637642, 0.6965797543525696, 0.4864007234573364, 0.4435647428035736}, {-0.285139262676239, 0.3857232630252838, 0.24143584072589874, 0.649742603302002, 0.06981214880943298, -0.6125373244285583, 0.01733512245118618, 0.07932000607252121, 0.5181733965873718, -1.1963340044021606, 0.40404781699180603, -0.14615681767463684, 0.6186272501945496, -1.1457765102386475, -1.0739068984985352, -0.2798802852630615}, {1.1909335851669312, -0.4514460265636444, 0.30036303400993347, -0.038285911083221436, 0.43672776222229004, -0.08062344789505005, 1.2637355327606201, 0.9915771484375, -1.2782515287399292, 0.5406272411346436, 0.2537979483604431, -0.4763562083244324, 0.29025453329086304, 1.3301706314086914, 0.12789936363697052, 1.6288628578186035}, {-0.08273261785507202, 0.23376059532165527, 0.28026238083839417, 0.1517716497182846, 0.11595846712589264, -0.2890694737434387, -0.16031892597675323, 0.20368246734142303, 0.08440088480710983, -0.25895506143569946, 0.26765018701553345, 0.10948746651411057, 0.0031156563200056553, -0.3320322632789612, -0.05543573945760727, -0.14434495568275452}, {-0.12529431283473969, -0.29864734411239624, -0.37014085054397583, 0.013174464926123619, -0.2511708736419678, 0.37107357382774353, -0.17170102894306183, -0.29593104124069214, -0.14129656553268433, -0.059697169810533524, -0.1257583498954773, 0.35714614391326904, -0.3553428649902344, 0.31362104415893555, 0.09576988965272903, 0.09499600529670715}, {-0.06186293065547943, -0.14299276471138, -0.0002636016870383173, -0.07840004563331604, -0.07470513880252838, 0.04816742613911629, 0.1160968542098999, 0.09385481476783752, 0.17176209390163422, 0.27059826254844666, -0.12432315200567245, 0.06464627385139465, 0.00946725718677044, -0.21058489382266998, 0.18171945214271545, -0.15431058406829834}, {-0.07999894767999649, 0.14399276673793793, -0.1960180103778839, -0.24657343327999115, -0.008633365854620934, 0.29167109727859497, -0.24385279417037964, 0.1545213907957077, -0.5268115401268005, 0.8321523070335388, -0.3172391653060913, -0.022196464240550995, -0.3843740224838257, 0.1311109960079193, 0.6241090893745422, 0.024305857717990875}, {0.6200766563415527, -0.42789188027381897, -0.20120689272880554, -0.2711464464664459, 0.06377248466014862, 0.4965742528438568, 0.13760791718959808, -0.10700463503599167, -0.6919744610786438, 0.9461080431938171, -0.25061216950416565, 0.07217248529195786, -0.27255043387413025, 1.5676292181015015, 0.5986578464508057, 0.056008920073509216}, {0.264791339635849, 0.13495679199695587, 0.039891526103019714, -0.23926527798175812, -0.00176772172562778, 0.21077857911586761, -0.1650940626859665, -0.09318730980157852, -0.1523580551147461, 0.5311816334724426, -0.4690065383911133, 0.09852688759565353, -0.47219446301460266, 0.280374675989151, 0.6609695553779602, -0.3257719576358795}, {0.02167564071714878, -0.04724881798028946, -0.20010265707969666, -0.24692383408546448, -0.33391404151916504, 0.609860897064209, 0.019992973655462265, 0.1883823424577713, -0.4617385268211365, 0.7394587993621826, -0.3989547789096832, -0.029024800285696983, -0.2078961730003357, 0.7404977679252625, 0.5931307077407837, -0.019464664161205292}, {-0.16188761591911316, 0.09441442787647247, 0.03940711170434952, -0.30846554040908813, 0.008287410251796246, 0.0065984949469566345, 0.01137496903538704, -0.03683881089091301, -0.17372305691242218, 0.5358720421791077, 0.14780159294605255, -0.17451223731040955, 0.07704617083072662, 0.2641890048980713, 0.5906860828399658, -0.07166134566068649}, {-0.47123008966445923, 0.13100510835647583, -0.06582566350698471, 0.26066017150878906, 0.0027384322602301836, 0.10938050597906113, -0.2695084512233734, -0.13236400485038757, 0.3165489435195923, -0.10713895410299301, -0.2027713805437088, 0.28841423988342285, 0.048626504838466644, 0.10849393904209137, -0.14665493369102478, -0.3522650897502899}, {0.264733225107193, -0.3303164839744568, -0.24371443688869476, -0.5756599307060242, -0.26967883110046387, 0.22950156033039093, 0.18690334260463715, -0.12316436320543289, -0.30677330493927, 1.0802727937698364, -0.2964709401130676, 0.07653062790632248, -0.4482121467590332, 0.8726921677589417, 0.8781095147132874, 0.2970518469810486}, {0.4326372444629669, -0.19034533202648163, -0.03185389190912247, -1.0341123342514038, -0.5905440449714661, 0.8352693319320679, -0.11525747179985046, 0.330589234828949, -1.2929764986038208, 1.6729471683502197, -0.004523536190390587, -0.05007949471473694, -0.3231196105480194, 1.1351120471954346, 1.4811056852340698, 0.039299484342336655}, {0.08650776743888855, 0.3421151041984558, -0.02308448776602745, -0.12855513393878937, -0.05939896032214165, 0.4321306049823761, -0.11589612066745758, 0.21009983122348785, -0.4068607687950134, 0.24023455381393433, -0.15275733172893524, 0.1030341386795044, -0.012459547258913517, 0.4063712954521179, 0.5671327114105225, -0.03711853548884392}, {0.029444128274917603, 0.32111167907714844, 0.00775943836197257, -0.6525279879570007, -0.09512899816036224, 0.06793954223394394, -0.10822902619838715, 0.22741948068141937, -0.22859175503253937, 0.554082989692688, -0.17973797023296356, 0.007612459361553192, -0.44436541199684143, 0.2914707362651825, 0.5088810920715332, -0.23432308435440063}, {0.0447772853076458, -0.07879838347434998, -0.2138407677412033, -0.15828625857830048, -0.08461622148752213, 0.374592661857605, -0.25888144969940186, -0.04517815634608269, -0.2779633700847626, 0.414657324552536, -0.2624884843826294, -0.011051212437450886, -0.4671292304992676, 0.7118108868598938, 0.48140549659729004, -0.035408567637205124}, {-0.4726046621799469, 0.04736251384019852, 0.08271242678165436, 0.6740482449531555, -0.03800680488348007, -0.4261839985847473, -0.2370775192975998, -0.40219739079475403, 0.6609380841255188, -0.7649049758911133, 0.16262361407279968, 0.012945768423378468, 0.39514803886413574, -0.5038082003593445, -0.6741383075714111, 0.03601602092385292}, {0.0738087147474289, -0.03494466468691826, -0.24799011647701263, -0.07100210338830948, -0.011058701202273369, 0.29095107316970825, -0.3025553524494171, -0.48599642515182495, -0.8302652835845947, 0.5655351877212524, -0.4390277564525604, 0.28480976819992065, -0.27761080861091614, 1.5692025423049927, 0.6453392505645752, -0.040705543011426926}, {-0.16674938797950745, 0.0018145975191146135, 0.2145673930644989, -0.5132133960723877, -0.10743217915296555, 0.039527494460344315, 0.1927245706319809, 0.29614898562431335, 0.09515076130628586, 0.07391539961099625, -0.007489118259400129, -0.15302352607250214, -0.2884466052055359, 0.050132300704717636, 0.61182701587677, 0.007777972146868706}, {0.16550509631633759, -0.3056091368198395, -0.13107997179031372, -0.12502530217170715, -0.28739503026008606, -0.18590503931045532, -0.06426427513360977, 0.10582008212804794, 0.058953192085027695, 0.1783776879310608, -0.30326205492019653, -0.0836266577243805, -0.22811700403690338, 0.07115120440721512, 0.13441726565361023, -0.11479014158248901}, {-0.30292168259620667, -0.6629642248153687, 0.04347614198923111, -0.001988725969567895, 0.28489136695861816, -0.2382131814956665, 0.12318027019500732, -0.04827270656824112, 0.5408399701118469, -0.589897096157074, -0.09773913025856018, -0.19087639451026917, -0.07534539699554443, 0.059134263545274734, -0.5233819484710693, 0.4272335469722748}, {0.031301334500312805, 0.42365506291389465, -0.12773673236370087, -0.30493444204330444, -0.08419366925954819, 0.40805554389953613, -0.11737024784088135, 0.24854835867881775, 0.05304279550909996, 0.3915049433708191, -0.39423251152038574, 0.22368285059928894, -0.2469666302204132, -0.10687536746263504, 0.600500226020813, -0.17710475623607635}, {0.3446366786956787, 0.46121475100517273, -0.010739211924374104, -0.5523761510848999, 0.030478330329060555, 0.25135982036590576, -0.010952124372124672, 0.01099466998130083, -0.20473773777484894, 0.35962238907814026, -0.1988791972398758, 0.07974319159984589, -0.33836624026298523, -0.09539127349853516, 0.30307289958000183, 0.09383081644773483}, {0.26984068751335144, -0.019096706062555313, -0.22856654226779938, -0.7374300360679626, -0.17740613222122192, 0.1746429055929184, -0.10033681988716125, 0.28845950961112976, -0.2496211975812912, 0.3991161584854126, -0.1791904717683792, -0.07793939858675003, 0.008162903599441051, -0.02104789763689041, 0.5999819040298462, 0.0535387322306633}, {-0.25286638736724854, 0.051806554198265076, 0.19085194170475006, 0.39153724908828735, -0.10504044592380524, -0.05344134569168091, 0.1493828147649765, -0.03267820179462433, 0.22592639923095703, -0.3267706632614136, -0.11452943086624146, -0.0011364337988197803, 0.009080976247787476, -0.13075166940689087, -0.07588564604520798, -0.15032191574573517}, {0.34894537925720215, 0.004341022111475468, 0.02968543767929077, -0.2118767648935318, -0.024753941223025322, 0.2652980089187622, 0.2637307941913605, 0.48942872881889343, -0.6163294315338135, 0.7233594059944153, -0.17922939360141754, -0.13630840182304382, -0.19022899866104126, 0.180150106549263, 0.5978638529777527, 0.017092809081077576}, {-0.22807453572750092, -0.6130339503288269, -0.14964288473129272, -0.07426222413778305, -0.14395880699157715, -0.1497572809457779, 0.03891139104962349, -0.08850275725126266, 0.014221434481441975, -0.1976293921470642, -0.22990110516548157, 0.034008242189884186, 0.1703946888446808, -0.0841677337884903, -0.0003616790927480906, 0.18203525245189667}, {0.1007569432258606, -0.00878661684691906, -0.1360444575548172, -0.031268078833818436, 0.09541045874357224, -0.18668606877326965, -0.10181421786546707, 0.1311570703983307, 0.20579521358013153, -0.10599330067634583, 0.09932146966457367, -0.2057129144668579, -0.15287674963474274, 0.1684466302394867, -0.05875242128968239, 0.05459976568818092}, {-0.08713299036026001, -0.33301034569740295, 0.11589361727237701, 0.4184105098247528, 0.16226503252983093, 0.01464671827852726, -0.09671645611524582, -0.2782222330570221, 0.1741669923067093, -0.3754129707813263, 0.024219084531068802, -0.21387892961502075, 0.20696882903575897, -0.4453827142715454, -0.45051684975624084, 0.21196751296520233}, {-0.01260970439761877, 0.0796942338347435, -0.009210338816046715, -0.3076384365558624, -0.20042389631271362, 0.23553960025310516, -0.25359055399894714, 0.39228716492652893, -0.26134243607521057, 0.12618036568164825, 0.1841745227575302, 0.14699645340442657, -0.2666090428829193, -0.17816561460494995, 0.34229329228401184, -0.11172647029161453}, {-0.008279218338429928, -0.005250335205346346, -0.12852619588375092, 0.4752219021320343, 0.3074682056903839, -0.2930559813976288, -0.015468846075236797, -0.3743225634098053, 0.3881418704986572, -0.3658682107925415, -0.2007196545600891, 0.226669043302536, -0.10542995482683182, -0.2798685133457184, -0.4119427502155304, -0.15576927363872528}, {0.28272318840026855, 0.11767629534006119, 0.1096596047282219, -0.290880411863327, 0.03461924567818642, 0.17111316323280334, -0.2074454426765442, 0.23408232629299164, 0.07494963705539703, 0.0963684692978859, 0.10303957760334015, 0.023704437538981438, 0.12210310995578766, -0.18075239658355713, 0.12428880482912064, -0.11006597429513931}, {0.5518311858177185, 0.01603684201836586, -0.10721796751022339, -0.42796656489372253, -0.24188333749771118, -0.006172939669340849, -0.04669475927948952, 0.3686703145503998, -0.5912966728210449, 1.0193204879760742, -0.2106480747461319, -0.15113356709480286, -0.29440805315971375, 0.2661497890949249, 0.6687009930610657, 0.10365614295005798}, {-0.27735474705696106, -0.1896292120218277, 0.14795660972595215, 0.19006042182445526, -0.22061781585216522, -0.21967606246471405, -0.14090214669704437, -0.05610566586256027, 0.36878424882888794, -0.39688587188720703, 0.11359493434429169, 0.055656399577856064, 0.28147169947624207, -0.1987834870815277, -0.4424634575843811, -0.03830036148428917}, {0.1831718236207962, -0.09909682720899582, 0.16653186082839966, -0.22623620927333832, -0.3702658414840698, 0.19768762588500977, -0.10973409563302994, 0.3155815303325653, -0.48624271154403687, 0.7076459527015686, 0.03737004101276398, 0.19611340761184692, -0.06911429762840271, 0.10408958792686462, 0.7297992706298828, 0.22961631417274475}, {0.053376033902168274, -0.8298205137252808, 0.5052531361579895, 0.4323894679546356, 0.32983341813087463, -0.21214556694030762, 0.15272769331932068, -0.411590576171875, -0.10829636454582214, -0.045464806258678436, 0.48047688603401184, -0.055599164217710495, 0.19228225946426392, 0.8843986988067627, 0.09335748851299286, 0.4010363221168518}, {-0.24603371322155, -0.6592891216278076, 0.46705254912376404, 0.719771146774292, 0.46816742420196533, -0.4952259957790375, 0.692439615726471, -0.14929014444351196, 0.7989322543144226, -1.0770162343978882, 0.5103569030761719, -0.0838145837187767, 0.6461833119392395, -0.3075953722000122, -0.8171088099479675, 0.7503623366355896}, {0.3657210171222687, 0.05476115643978119, 0.012749924324452877, -0.28133758902549744, -0.1140303984284401, 0.16562777757644653, 0.03732599318027496, 0.3869434595108032, -0.22798068821430206, 0.25736579298973083, -0.03641148656606674, 0.2116290032863617, -0.27965420484542847, 0.6341499090194702, 0.543471097946167, 0.2831423878669739}, {1.3015782833099365, -1.1018532514572144, 0.7868087887763977, 0.2046445608139038, 0.4709206819534302, 0.13532187044620514, 1.708228349685669, 0.8535500168800354, -1.3007701635360718, 0.7300502061843872, 0.34874337911605835, -0.4542366564273834, 0.1633729189634323, 1.7215148210525513, 0.5437059998512268, 1.580246925354004}, {0.27555525302886963, -0.19433945417404175, 0.1777447760105133, -0.7541574835777283, -0.3039226531982422, 0.4769143760204315, 0.32457658648490906, 0.16775494813919067, -0.3244243264198303, 0.32306763529777527, -0.20245617628097534, -0.04909480735659599, -0.4044874906539917, 0.44537022709846497, 1.0358808040618896, -0.06047356501221657}, {0.15495789051055908, 0.214009627699852, 0.21057820320129395, -0.23611865937709808, 0.15313799679279327, 0.36965101957321167, 0.03875754028558731, 0.2618919014930725, -0.8124748468399048, 0.6357295513153076, 0.20073963701725006, 0.059097714722156525, -0.11416397243738174, 0.8201794624328613, 0.5192725658416748, 0.35022270679473877}, {0.09685884416103363, 0.2437777817249298, -0.018126284703612328, -0.28249314427375793, -0.23142096400260925, -0.031612589955329895, -0.09093291312456131, 0.4216604232788086, -0.17310236394405365, 0.029570845887064934, 0.22673292458057404, -0.13684342801570892, -0.0020273958798497915, 0.0015412168577313423, 0.286274790763855, -0.10109617561101913}, {0.032674018293619156, -0.7374882102012634, 0.5229865312576294, 0.6408478021621704, 0.6575783491134644, -0.49683162569999695, 0.8733084201812744, -0.2033771574497223, 0.08547986298799515, -0.27707138657569885, 0.46976375579833984, -0.3590454161167145, 0.21666958928108215, 0.6740771532058716, -0.572298526763916, 0.7978286147117615}, {0.1498858481645584, -0.40130794048309326, 0.18406003713607788, 0.0734860748052597, 0.2902072072029114, -0.21494944393634796, 0.620833158493042, 0.015805328264832497, -0.26214438676834106, 0.9347289204597473, 0.48622453212738037, -0.47637251019477844, 0.016305187717080116, 0.9201464653015137, 0.5032175779342651, 0.5159721374511719}, {0.4389854967594147, 0.011539853177964687, 0.7644362449645996, 0.2932069003582001, 0.3993307948112488, -0.25179436802864075, 1.1375093460083008, 0.5483322739601135, -0.31534624099731445, 0.03249075636267662, 0.22539427876472473, -0.6536896228790283, 0.5816919207572937, 1.3394490480422974, -0.2792820930480957, 1.2593013048171997}, {0.4926902949810028, -0.03529808297753334, -0.004849703051149845, -0.13120830059051514, -0.25277718901634216, 0.31014320254325867, 0.11285202205181122, 0.4780700206756592, -0.35612741112709045, 0.7577961683273315, -0.31448107957839966, 0.17637918889522552, -0.16208206117153168, 0.5682644844055176, 0.657059907913208, 0.2745938003063202}, {0.2884586751461029, -0.016377616673707962, -0.0007302358280867338, -0.3204934597015381, -0.1694975048303604, 0.10806680470705032, -0.05880051478743553, 0.14218369126319885, -0.0325084812939167, 0.6034473180770874, -0.07142477482557297, 0.19469112157821655, -0.345002681016922, -0.05715342238545418, 0.40300607681274414, -0.05151418223977089}, {0.5535184144973755, 0.07598679512739182, -0.002866586670279503, -0.18291519582271576, -0.18783017992973328, 0.2943700850009918, 0.24271461367607117, 0.3177736699581146, -0.3807275891304016, 0.8250764608383179, 0.14298444986343384, 0.12588796019554138, -0.13065217435359955, 0.619009792804718, 0.4156271517276764, 0.16434070467948914}, {-0.22943057119846344, 0.20314718782901764, 0.2258203774690628, 0.7583217024803162, 0.48794129490852356, -0.34288695454597473, 0.051822785288095474, -0.2610410451889038, 0.7256613373756409, -1.0470304489135742, 0.02080669440329075, -0.03617950528860092, 0.37454408407211304, -0.524467945098877, -0.6721466183662415, -0.13930240273475647}, {0.9959986805915833, -0.13158975541591644, 0.564915120601654, 0.4674662947654724, 0.6846804618835449, -0.25875043869018555, 1.0065211057662964, 0.2734551429748535, -0.6884541511535645, 0.5883671641349792, 0.5766497254371643, -0.30978167057037354, 0.21855974197387695, 1.2222176790237427, 0.010631117038428783, 1.232257604598999}, {0.2671847343444824, 0.3236081302165985, 0.08929549902677536, 0.06075170263648033, -0.011490557342767715, -0.0837290808558464, -0.08086252212524414, 0.5147456526756287, 0.07011795043945312, -0.14420174062252045, 0.20650073885917664, -0.22913683950901031, -0.17583422362804413, -0.05249859020113945, -0.1477516144514084, -0.12112020701169968} };
	double bi[64] = { 0.4767051339149475, 0.14697177708148956, 0.08589546382427216, 0.6045029759407043, 0.013440510258078575, 0.262433260679245, 0.10965510457754135, 0.16749031841754913, 0.6668431758880615, 0.8190640211105347, -0.09450654685497284, -0.12179023772478104, 0.2562447786331177, 0.36145341396331787, 0.2886488139629364, -0.11642397195100784, 0.04098469391465187, -0.4798317551612854, -0.0062423935160040855, -0.22535263001918793, -0.3121128976345062, -0.10167214274406433, -0.02079661749303341, -0.42471563816070557, 0.1833944022655487, 0.2007877230644226, -0.15312087535858154, 0.09627918154001236, -0.3435336947441101, 0.09101757407188416, -0.24484048783779144, 0.014279539696872234, 0.05199733376502991, 0.0032729837112128735, 0.09579131752252579, 0.2632316052913666, 0.11006052047014236, -0.18169359862804413, -0.04864688590168953, 0.015323914587497711, -0.22113658487796783, 0.14131425321102142, 0.05898334085941315, -0.12508781254291534, -0.0023106562439352274, 0.06893936544656754, -0.12010221183300018, 0.23169337213039398, 0.41194528341293335, -0.06206938624382019, 0.19555681943893433, 0.706588089466095, 0.36283403635025024, -0.06609782576560974, 0.07228700816631317, -0.10035773366689682, 0.21413926780223846, 0.8548502326011658, 0.16911928355693817, 0.08355634659528732, 0.31451308727264404, 0.08069328963756561, 0.4875659942626953, 0.2880845367908478 };
	double bh[64] = { 0.13206696510314941, -0.2590027153491974, 0.18607638776302338, 0.8163014054298401, 0.06651800870895386, 0.3285820186138153, 0.10249218344688416, 0.1778639853000641, 0.703565239906311, 0.7346901893615723, 0.04261130839586258, 0.06829691678285599, 0.02474079094827175, 0.0068076071329414845, 0.5378856658935547, 0.3165321946144104, 0.06200636923313141, -0.4812186360359192, -0.10374494642019272, -0.3118670880794525, -0.0027482067234814167, 0.008040627464652061, -0.12830036878585815, -0.10168890655040741, -0.04114025831222534, 0.1258399784564972, -0.04313136264681816, 0.21505190432071686, 0.09417634457349777, 0.23749051988124847, -0.21526682376861572, -0.14993499219417572, -0.0793541967868805, -0.343729168176651, 0.0781286358833313, -0.0899181216955185, -0.08961816877126694, 0.06887819617986679, 0.23690372705459595, -0.05998682230710983, 0.027152735739946365, 0.05899916961789131, 0.18405038118362427, -0.1802876889705658, 0.1577335149049759, -0.056625477969646454, 0.10332980751991272, -0.071870818734169, 0.12401177734136581, 0.022405702620744705, 0.05020993575453758, 0.7662148475646973, 0.16411741077899933, 0.16536077857017517, 0.12262425571680069, 0.08903482556343079, 0.40329307317733765, 0.48940110206604004, 0.27685239911079407, -0.10927826166152954, 0.09391435235738754, 0.23901715874671936, 0.44981059432029724, 0.13821429014205933 };
	double linearw[16] = { -0.2456, -0.1777, 0.1366, 0.5294, 0.2067, -0.3147, 0.2837, -0.2347,0.4089, -0.5373, 0.2808, -0.2407, 0.2783, 0.1658, -0.5950, 0.2259 };
	double linearb = -0.1108;
	double pre(double rtts[3]) {
		double h[16] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
		double c[16] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
		double it[16],fi[16],gt[16],ot[16];
		for (int i = 0; i < 3; i++) {
			cell(it, wi, wh, bi, bh, rtts[i], h, 0);
			cell(fi, wi + 16, &(wh[16]), bi + 16, bh + 16, rtts[i], h, 0);
			cell(gt, wi + 32, &(wh[32]), bi + 32, bh + 32, rtts[i], h, 1);
			cell(ot, wi + 48, &(wh[48]), bi + 48, bh + 48, rtts[i], h, 0);
			for (int j = 0; j < 16; j++) {
				c[j] = fi[j] * c[j] + it[j] * gt[j];
				h[j] = ot[j] * tanh(c[j]);		
			}
		}
		double out = linearb;
		for (int i = 0; i < 16; i++) {
			out += h[i] * linearw[i];
		}
		return out;
	}
	double  characteristic_value(double* rttsd, double rtt[3]) {
		rttsd[0] = a * rtts + (1 - a) * rtt[0];
		rttsd[1] = a * rttsd[0] + (1 - a) * rtt[1];
		rttsd[2] = a * rttsd[1] + (1 - a) * rtt[2];
		double rttsd2 = rttsd[2];
		rtts = rttsd[0];
		rttsd[0] = (rtt[0] - rttsd[0]) / (rttsd[0]);
		rttsd[1] = (rtt[1] - rttsd[1]) / (rttsd[1]);
		rttsd[2] = (rtt[2] - rttsd[2]) / (rttsd[2]);
		return rttsd2;
	}
	void cell(double ou[16], double wi[16], double wh[16][16], double bi[16], double bh[16], double x, double h[16], int fuc) {
		for (int i = 0; i < 16; i++) {
			ou[i] = wi[i]*x+bi[i]+bh[i];
			for (int j = 0; j < 16; j++)
				ou[i] += wh[i][j] * h[j];
			if (fuc == 0)
				ou[i] = sigmod(ou[i]);
			else
				ou[i] = tanh(ou[i]);
		}
	}
	double sigmod(double x) {
		return 1 / (1 + exp(-x));
	}
	double tanh(double x) {
		return (exp(x) - exp(-x)) / (exp(x) + exp(-x));
	}
	double rtt_p(double rtt[3],double* rts) {
		rtts = *rts;
		double rttsd[3];
		double rttsd2=characteristic_value(rttsd, rtt);	
		*rts = rtts;
		double o = pre(rttsd);
		printf("s:.%3lf %.3lf %.3lf o:%.3lf %.3lf\n",rtt[0],rtt[1],rtt[2],o,rttsd2);
		return rttsd2 * (1 + o);
	}
};
class pidnn
{
public:
	double er = 0;
	double erold = 0;
	double outp = 0;
	double outi = 0;
	double outd = 0;
	double wp = -0.358;//
	double wi = -0.06;//-0.1
	double wd = 0.04;//0.17
	double rtt1 = 4.176;//init rtt=4176us
	double rtttarget = 5;//5us
	double targetch = 0;
	int tim = 0;
	double out = 0;
	double rate = 1;
	double rateold = 1;
	double gradcompute(double rttnew,int i) {

		double dj_drtt = (rttnew - rtttarget);
		double drtt_drate = 1;//(rttnew - rtt) / (rate-rateold);
		double dj_dw;
		if(i==0)
			dj_dw = dj_drtt*drtt_drate *outp;
		else if(i==1)
			dj_dw = dj_drtt* drtt_drate *outi;
		else
			dj_dw = dj_drtt* drtt_drate *outd;
		//printf("%.3lf %.3lf %.3lf",dj_drtt,dj_dw,outp);
		if(dj_dw>0.1)dj_dw = 0.1;
		else if(dj_dw<-0.1)dj_dw = -0.1;
		return dj_dw;
	}
	double get_learn_rate() {
		
		return 0.01 / (sqrt(tim + 1));
		//return 0.01;
	}
	double param_update(double rttnew) {
		rtt1 = rttnew;
		erold = er;
		er = (rttnew - rtttarget)/rtttarget;
		outp = er;
		outi = (er + outi*tim)/(tim+1);
		outd = er - erold;
		out = nnout();
		// rateold = rate;
		tim = tim +1;
		// rate = rateold * (1 - out);
		// if(rate<1)rate = 1;
		// else if(rate>100)rate =100;
		//printf("%.3lf %.3lf\n",rate,rateold);
		return nnout();
		//param update:rate,out,time,w_
	}
	void wupdate(double rttnew) {
		double learn = get_learn_rate();
		for (int i = 0; i < 3; i++) {
			double grad = gradcompute(rttnew,i);

			if (grad == 0) {  return; }
			if(i==0)
				wp = wp - learn * grad;
			if(i==1)
				wi = wi - learn * grad;
			if(i==2)
				wd = wd - learn * grad;
		}
	}
	double nnout() {
		double c = wp * outp + wi * outi + wd * outd;
		return c;
	}
	double process(double rtt,double rttnew,int nod) {
		double c;
		//wupdate(rtt);
		c = param_update(rttnew);
		//rtttarget_ch(rtt);
		return c;
	}
	void rtttarget_ch(double rtt){
			if(rtt!=rtttarget){
				int d = (rtt-rtttarget)>0?1:-1;
				if(targetch*d>=0)
					targetch+=d;
				else targetch=0;
			}else targetch = 0;
			if(targetch>6 || targetch<-6){
				rtttarget+=outi;
				targetch = 0;
			}
	}
};

pidnn pids[320];
rtt_pred rtt_predict;
double rtts[320][4] = {{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},{4176,4176,4176,4176},
};











RdmaHw::RdmaHw(){
}

void RdmaHw::SetNode(Ptr<Node> node){
	m_node = node;
}
void RdmaHw::Setup(QpCompleteCallback cb){
	for (uint32_t i = 0; i < m_nic.size(); i++){
		Ptr<QbbNetDevice> dev = m_nic[i].dev;
		if (dev == NULL)
			continue;
		// share data with NIC
		dev->m_rdmaEQ->m_qpGrp = m_nic[i].qpGrp;
		// setup callback
		dev->m_rdmaReceiveCb = MakeCallback(&RdmaHw::Receive, this);
		dev->m_rdmaLinkDownCb = MakeCallback(&RdmaHw::SetLinkDown, this);
		dev->m_rdmaPktSent = MakeCallback(&RdmaHw::PktSent, this);
		// config NIC
		dev->m_rdmaEQ->m_rdmaGetNxtPkt = MakeCallback(&RdmaHw::GetNxtPacket, this);
	}
	// setup qp complete callback
	m_qpCompleteCallback = cb;
}

uint32_t RdmaHw::GetNicIdxOfQp(Ptr<RdmaQueuePair> qp){
	auto &v = m_rtTable[qp->dip.Get()];
	if (v.size() > 0){
		return v[qp->GetHash() % v.size()];
	}else{
		NS_ASSERT_MSG(false, "We assume at least one NIC is alive");
	}
}
uint64_t RdmaHw::GetQpKey(uint32_t dip, uint16_t sport, uint16_t pg){
	return ((uint64_t)dip << 32) | ((uint64_t)sport << 16) | (uint64_t)pg;
}
Ptr<RdmaQueuePair> RdmaHw::GetQp(uint32_t dip, uint16_t sport, uint16_t pg){
	uint64_t key = GetQpKey(dip, sport, pg);
	auto it = m_qpMap.find(key);
	if (it != m_qpMap.end())
		return it->second;
	return NULL;
}
void RdmaHw::AddQueuePair(uint64_t size, uint16_t pg, Ipv4Address sip, Ipv4Address dip, uint16_t sport, uint16_t dport, uint32_t win, uint64_t baseRtt, Callback<void> notifyAppFinish){
	// create qp
	Ptr<RdmaQueuePair> qp = CreateObject<RdmaQueuePair>(pg, sip, dip, sport, dport);
	qp->SetSize(size);
	qp->SetWin(win);
	qp->SetBaseRtt(baseRtt);
	qp->SetVarWin(m_var_win);
	qp->SetAppNotifyCallback(notifyAppFinish);

	// add qp
	uint32_t nic_idx = GetNicIdxOfQp(qp);
	m_nic[nic_idx].qpGrp->AddQp(qp);
	uint64_t key = GetQpKey(dip.Get(), sport, pg);
	m_qpMap[key] = qp;

	// set init variables
	DataRate m_bps = m_nic[nic_idx].dev->GetDataRate();
	qp->m_rate = m_bps/10;
	qp->m_max_rate = m_bps;
	if (m_cc_mode == 1){
		qp->mlx.m_targetRate = m_bps;
	}else if (m_cc_mode == 3){
		qp->hp.m_curRate = m_bps;
		if (m_multipleRate){
			for (uint32_t i = 0; i < IntHeader::maxHop; i++)
				qp->hp.hopState[i].Rc = m_bps;
		}
	}else if (m_cc_mode == 7){
		qp->tmly.m_curRate = m_bps/10;
	}else if (m_cc_mode == 10){
		qp->hpccPint.m_curRate = m_bps;
	}

	// Notify Nic
	m_nic[nic_idx].dev->NewQp(qp);
}

void RdmaHw::DeleteQueuePair(Ptr<RdmaQueuePair> qp){
	// remove qp from the m_qpMap
	uint64_t key = GetQpKey(qp->dip.Get(), qp->sport, qp->m_pg);
	m_qpMap.erase(key);
}

Ptr<RdmaRxQueuePair> RdmaHw::GetRxQp(uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport, uint16_t pg, bool create){
	uint64_t key = ((uint64_t)dip << 32) | ((uint64_t)pg << 16) | (uint64_t)dport;
	auto it = m_rxQpMap.find(key);
	if (it != m_rxQpMap.end())
		return it->second;
	if (create){
		// create new rx qp
		Ptr<RdmaRxQueuePair> q = CreateObject<RdmaRxQueuePair>();
		// init the qp
		q->sip = sip;
		q->dip = dip;
		q->sport = sport;
		q->dport = dport;
		q->m_ecn_source.qIndex = pg;
		// store in map
		m_rxQpMap[key] = q;
		return q;
	}
	return NULL;
}
uint32_t RdmaHw::GetNicIdxOfRxQp(Ptr<RdmaRxQueuePair> q){
	auto &v = m_rtTable[q->dip];
	if (v.size() > 0){
		return v[q->GetHash() % v.size()];
	}else{
		NS_ASSERT_MSG(false, "We assume at least one NIC is alive");
	}
}
void RdmaHw::DeleteRxQp(uint32_t dip, uint16_t pg, uint16_t dport){
	uint64_t key = ((uint64_t)dip << 32) | ((uint64_t)pg << 16) | (uint64_t)dport;
	m_rxQpMap.erase(key);
}

int RdmaHw::ReceiveUdp(Ptr<Packet> p, CustomHeader &ch){
	uint8_t ecnbits = ch.GetIpv4EcnBits();

	uint32_t payload_size = p->GetSize() - ch.GetSerializedSize();

	// TODO find corresponding rx queue pair
	Ptr<RdmaRxQueuePair> rxQp = GetRxQp(ch.dip, ch.sip, ch.udp.dport, ch.udp.sport, ch.udp.pg, true);
	if (ecnbits != 0){
		rxQp->m_ecn_source.ecnbits |= ecnbits;
		rxQp->m_ecn_source.qfb++;
	}
	rxQp->m_ecn_source.total++;
	rxQp->m_milestone_rx = m_ack_interval;

	int x = ReceiverCheckSeq(ch.udp.seq, rxQp, payload_size);
	if (x == 1 || x == 2){ //generate ACK or NACK
		qbbHeader seqh;
		seqh.SetSeq(rxQp->ReceiverNextExpectedSeq);
		seqh.SetPG(ch.udp.pg);
		seqh.SetSport(ch.udp.dport);
		seqh.SetDport(ch.udp.sport);
		seqh.SetIntHeader(ch.udp.ih);
		if (ecnbits)
			seqh.SetCnp();

		Ptr<Packet> newp = Create<Packet>(std::max(60-14-20-(int)seqh.GetSerializedSize(), 0));
		newp->AddHeader(seqh);

		Ipv4Header head;	// Prepare IPv4 header
		head.SetDestination(Ipv4Address(ch.sip));
		head.SetSource(Ipv4Address(ch.dip));
		head.SetProtocol(x == 1 ? 0xFC : 0xFD); //ack=0xFC nack=0xFD
		head.SetTtl(64);
		head.SetPayloadSize(newp->GetSize());
		head.SetIdentification(rxQp->m_ipid++);

		newp->AddHeader(head);
		AddHeader(newp, 0x800);	// Attach PPP header
		// send
		uint32_t nic_idx = GetNicIdxOfRxQp(rxQp);
		m_nic[nic_idx].dev->RdmaEnqueueHighPrioQ(newp);
		m_nic[nic_idx].dev->TriggerTransmit();
	}
	return 0;
}

int RdmaHw::ReceiveCnp(Ptr<Packet> p, CustomHeader &ch){
	// QCN on NIC
	// This is a Congestion signal
	// Then, extract data from the congestion packet.
	// We assume, without verify, the packet is destinated to me
	uint32_t qIndex = ch.cnp.qIndex;
	if (qIndex == 1){		//DCTCP
		std::cout << "TCP--ignore\n";
		return 0;
	}
	uint16_t udpport = ch.cnp.fid; // corresponds to the sport
	uint8_t ecnbits = ch.cnp.ecnBits;
	uint16_t qfb = ch.cnp.qfb;
	uint16_t total = ch.cnp.total;

	uint32_t i;
	// get qp
	Ptr<RdmaQueuePair> qp = GetQp(ch.sip, udpport, qIndex);
	if (qp == NULL)
		std::cout << "ERROR: QCN NIC cannot find the flow\n";
	// get nic
	uint32_t nic_idx = GetNicIdxOfQp(qp);
	Ptr<QbbNetDevice> dev = m_nic[nic_idx].dev;

	if (qp->m_rate == 0)			//lazy initialization	
	{
		qp->m_rate = dev->GetDataRate();
		if (m_cc_mode == 1){
			qp->mlx.m_targetRate = dev->GetDataRate();
		}else if (m_cc_mode == 3){
			qp->hp.m_curRate = dev->GetDataRate();
			if (m_multipleRate){
				for (uint32_t i = 0; i < IntHeader::maxHop; i++)
					qp->hp.hopState[i].Rc = dev->GetDataRate();
			}
		}else if (m_cc_mode == 7){
			qp->tmly.m_curRate = dev->GetDataRate();
		}else if (m_cc_mode == 10){
			qp->hpccPint.m_curRate = dev->GetDataRate();
		}
	}
	return 0;
}

int RdmaHw::ReceiveAck(Ptr<Packet> p, CustomHeader &ch){
	uint16_t qIndex = ch.ack.pg;
	uint16_t port = ch.ack.dport;
	uint32_t seq = ch.ack.seq;
	uint8_t cnp = (ch.ack.flags >> qbbHeader::FLAG_CNP) & 1;
	int i;
	Ptr<RdmaQueuePair> qp = GetQp(ch.sip, port, qIndex);
	if (qp == NULL){
		std::cout << "ERROR: " << "node:" << m_node->GetId() << ' ' << (ch.l3Prot == 0xFC ? "ACK" : "NACK") << " NIC cannot find the flow\n";
		return 0;
	}

	uint32_t nic_idx = GetNicIdxOfQp(qp);
	Ptr<QbbNetDevice> dev = m_nic[nic_idx].dev;
	if (m_ack_interval == 0)
		std::cout << "ERROR: shouldn't receive ack\n";
	else {
		if (!m_backto0){
			qp->Acknowledge(seq);
		}else {
			uint32_t goback_seq = seq / m_chunk * m_chunk;
			qp->Acknowledge(goback_seq);
		}
		if (qp->IsFinished()){
			QpComplete(qp);
		}
	}
	if (ch.l3Prot == 0xFD) // NACK
		RecoverQueue(qp);

	// handle cnp
	if (cnp){
		if (m_cc_mode == 1){ // mlx version
			cnp_received_mlx(qp);
		} 
	}

	if (m_cc_mode == 3){
		HandleAckHp(qp, p, ch);
	}else if (m_cc_mode == 7){
		HandleAckTimely(qp, p, ch);
	}else if (m_cc_mode == 8){
		HandleAckDctcp(qp, p, ch);
	}else if (m_cc_mode == 10){
		HandleAckHpPint(qp, p, ch);
	}
	// ACK may advance the on-the-fly window, allowing more packets to send
	dev->TriggerTransmit();
	return 0;
}

int RdmaHw::Receive(Ptr<Packet> p, CustomHeader &ch){
	if (ch.l3Prot == 0x11){ // UDP
		ReceiveUdp(p, ch);
	}else if (ch.l3Prot == 0xFF){ // CNP
		ReceiveCnp(p, ch);
	}else if (ch.l3Prot == 0xFD){ // NACK
		ReceiveAck(p, ch);
	}else if (ch.l3Prot == 0xFC){ // ACK
		ReceiveAck(p, ch);
	}
	return 0;
}

int RdmaHw::ReceiverCheckSeq(uint32_t seq, Ptr<RdmaRxQueuePair> q, uint32_t size){
	uint32_t expected = q->ReceiverNextExpectedSeq;
	if (seq == expected){
		q->ReceiverNextExpectedSeq = expected + size;
		if (q->ReceiverNextExpectedSeq >= q->m_milestone_rx){
			q->m_milestone_rx += m_ack_interval;
			return 1; //Generate ACK
		}else if (q->ReceiverNextExpectedSeq % m_chunk == 0){
			return 1;
		}else {
			return 5;
		}
	} else if (seq > expected) {
		// Generate NACK
		if (Simulator::Now() >= q->m_nackTimer || q->m_lastNACK != expected){
			q->m_nackTimer = Simulator::Now() + MicroSeconds(m_nack_interval);
			q->m_lastNACK = expected;
			if (m_backto0){
				q->ReceiverNextExpectedSeq = q->ReceiverNextExpectedSeq / m_chunk*m_chunk;
			}
			return 2;
		}else
			return 4;
	}else {
		// Duplicate. 
		return 3;
	}
}
void RdmaHw::AddHeader (Ptr<Packet> p, uint16_t protocolNumber){
	PppHeader ppp;
	ppp.SetProtocol (EtherToPpp (protocolNumber));
	p->AddHeader (ppp);
}
uint16_t RdmaHw::EtherToPpp (uint16_t proto){
	switch(proto){
		case 0x0800: return 0x0021;   //IPv4
		case 0x86DD: return 0x0057;   //IPv6
		default: NS_ASSERT_MSG (false, "PPP Protocol number not defined!");
	}
	return 0;
}

void RdmaHw::RecoverQueue(Ptr<RdmaQueuePair> qp){
	qp->snd_nxt = qp->snd_una;
}

void RdmaHw::QpComplete(Ptr<RdmaQueuePair> qp){
	NS_ASSERT(!m_qpCompleteCallback.IsNull());
	if (m_cc_mode == 1){
		Simulator::Cancel(qp->mlx.m_eventUpdateAlpha);
		Simulator::Cancel(qp->mlx.m_eventDecreaseRate);
		Simulator::Cancel(qp->mlx.m_rpTimer);
	}

	// This callback will log info
	// It may also delete the rxQp on the receiver
	m_qpCompleteCallback(qp);

	qp->m_notifyAppFinish();

	// delete the qp
	DeleteQueuePair(qp);
}

void RdmaHw::SetLinkDown(Ptr<QbbNetDevice> dev){
	printf("RdmaHw: node:%u a link down\n", m_node->GetId());
}

void RdmaHw::AddTableEntry(Ipv4Address &dstAddr, uint32_t intf_idx){
	uint32_t dip = dstAddr.Get();
	m_rtTable[dip].push_back(intf_idx);
}

void RdmaHw::ClearTable(){
	m_rtTable.clear();
}

void RdmaHw::RedistributeQp(){
	// clear old qpGrp
	for (uint32_t i = 0; i < m_nic.size(); i++){
		if (m_nic[i].dev == NULL)
			continue;
		m_nic[i].qpGrp->Clear();
	}

	// redistribute qp
	for (auto &it : m_qpMap){
		Ptr<RdmaQueuePair> qp = it.second;
		uint32_t nic_idx = GetNicIdxOfQp(qp);
		m_nic[nic_idx].qpGrp->AddQp(qp);
		// Notify Nic
		m_nic[nic_idx].dev->ReassignedQp(qp);
	}
}

Ptr<Packet> RdmaHw::GetNxtPacket(Ptr<RdmaQueuePair> qp){
	uint32_t payload_size = qp->GetBytesLeft();
	if (m_mtu < payload_size)
		payload_size = m_mtu;
	Ptr<Packet> p = Create<Packet> (payload_size);
	// add SeqTsHeader
	SeqTsHeader seqTs;
	seqTs.SetSeq (qp->snd_nxt);
	seqTs.SetPG (qp->m_pg);
	p->AddHeader (seqTs);
	// add udp header
	UdpHeader udpHeader;
	udpHeader.SetDestinationPort (qp->dport);
	udpHeader.SetSourcePort (qp->sport);
	p->AddHeader (udpHeader);
	// add ipv4 header
	Ipv4Header ipHeader;
	ipHeader.SetSource (qp->sip);
	ipHeader.SetDestination (qp->dip);
	ipHeader.SetProtocol (0x11);
	ipHeader.SetPayloadSize (p->GetSize());
	ipHeader.SetTtl (64);
	ipHeader.SetTos (0);
	ipHeader.SetIdentification (qp->m_ipid);
	p->AddHeader(ipHeader);
	// add ppp header
	PppHeader ppp;
	ppp.SetProtocol (0x0021); // EtherToPpp(0x800), see point-to-point-net-device.cc
	p->AddHeader (ppp);

	// update state
	qp->snd_nxt += payload_size;
	qp->m_ipid++;

	// return
	return p;
}

void RdmaHw::PktSent(Ptr<RdmaQueuePair> qp, Ptr<Packet> pkt, Time interframeGap){
	qp->lastPktSize = pkt->GetSize();
	UpdateNextAvail(qp, interframeGap, pkt->GetSize());
}

void RdmaHw::UpdateNextAvail(Ptr<RdmaQueuePair> qp, Time interframeGap, uint32_t pkt_size){
	Time sendingTime;
	if (m_rateBound)
		sendingTime = interframeGap + Seconds(qp->m_rate.CalculateTxTime(pkt_size));
	else
		sendingTime = interframeGap + Seconds(qp->m_max_rate.CalculateTxTime(pkt_size));
	qp->m_nextAvail = Simulator::Now() + sendingTime;
}

void RdmaHw::ChangeRate(Ptr<RdmaQueuePair> qp, DataRate new_rate){
	#if 1
	Time sendingTime = Seconds(qp->m_rate.CalculateTxTime(qp->lastPktSize));
	Time new_sendintTime = Seconds(new_rate.CalculateTxTime(qp->lastPktSize));
	qp->m_nextAvail = qp->m_nextAvail + new_sendintTime - sendingTime;
	// update nic's next avail event
	uint32_t nic_idx = GetNicIdxOfQp(qp);
	m_nic[nic_idx].dev->UpdateNextAvail(qp->m_nextAvail);
	#endif

	// change to new rate
	qp->m_rate = new_rate;
}

#define PRINT_LOG 0
/******************************
 * Mellanox's version of DCQCN
 *****************************/
void RdmaHw::UpdateAlphaMlx(Ptr<RdmaQueuePair> q){
	#if PRINT_LOG
	//std::cout << Simulator::Now() << " alpha update:" << m_node->GetId() << ' ' << q->mlx.m_alpha << ' ' << (int)q->mlx.m_alpha_cnp_arrived << '\n';
	//printf("%lu alpha update: %08x %08x %u %u %.6lf->", Simulator::Now().GetTimeStep(), q->sip.Get(), q->dip.Get(), q->sport, q->dport, q->mlx.m_alpha);
	#endif
	if (q->mlx.m_alpha_cnp_arrived){
		q->mlx.m_alpha = (1 - m_g)*q->mlx.m_alpha + m_g; 	//binary feedback
	}else {
		q->mlx.m_alpha = (1 - m_g)*q->mlx.m_alpha; 	//binary feedback
	}
	#if PRINT_LOG
	//printf("%.6lf\n", q->mlx.m_alpha);
	#endif
	q->mlx.m_alpha_cnp_arrived = false; // clear the CNP_arrived bit
	ScheduleUpdateAlphaMlx(q);
}
void RdmaHw::ScheduleUpdateAlphaMlx(Ptr<RdmaQueuePair> q){
	q->mlx.m_eventUpdateAlpha = Simulator::Schedule(MicroSeconds(m_alpha_resume_interval), &RdmaHw::UpdateAlphaMlx, this, q);
}

void RdmaHw::cnp_received_mlx(Ptr<RdmaQueuePair> q){
	q->mlx.m_alpha_cnp_arrived = true; // set CNP_arrived bit for alpha update
	q->mlx.m_decrease_cnp_arrived = true; // set CNP_arrived bit for rate decrease
	if (q->mlx.m_first_cnp){
		// init alpha
		q->mlx.m_alpha = 1;
		q->mlx.m_alpha_cnp_arrived = false;
		// schedule alpha update
		ScheduleUpdateAlphaMlx(q);
		// schedule rate decrease
		ScheduleDecreaseRateMlx(q, 1); // add 1 ns to make sure rate decrease is after alpha update
		// set rate on first CNP
		q->mlx.m_targetRate = q->m_rate = m_rateOnFirstCNP * q->m_rate;
		q->mlx.m_first_cnp = false;
	}
}

void RdmaHw::CheckRateDecreaseMlx(Ptr<RdmaQueuePair> q){
	ScheduleDecreaseRateMlx(q, 0);
	if (q->mlx.m_decrease_cnp_arrived){
		#if PRINT_LOG
		printf("%lu rate dec: %08x %08x %u %u (%0.3lf %.3lf)->", Simulator::Now().GetTimeStep(), q->sip.Get(), q->dip.Get(), q->sport, q->dport, q->mlx.m_targetRate.GetBitRate() * 1e-9, q->m_rate.GetBitRate() * 1e-9);
		#endif
		bool clamp = true;
		if (!m_EcnClampTgtRate){
			if (q->mlx.m_rpTimeStage == 0)
				clamp = false;
		}
		if (clamp)
			q->mlx.m_targetRate = q->m_rate;
		q->m_rate = std::max(m_minRate, q->m_rate * (1 - q->mlx.m_alpha / 2));
		// reset rate increase related things
		q->mlx.m_rpTimeStage = 0;
		q->mlx.m_decrease_cnp_arrived = false;
		Simulator::Cancel(q->mlx.m_rpTimer);
		q->mlx.m_rpTimer = Simulator::Schedule(MicroSeconds(m_rpgTimeReset), &RdmaHw::RateIncEventTimerMlx, this, q);
		#if PRINT_LOG
		printf("(%.3lf %.3lf)\n", q->mlx.m_targetRate.GetBitRate() * 1e-9, q->m_rate.GetBitRate() * 1e-9);
		#endif
	}
}
void RdmaHw::ScheduleDecreaseRateMlx(Ptr<RdmaQueuePair> q, uint32_t delta){
	q->mlx.m_eventDecreaseRate = Simulator::Schedule(MicroSeconds(m_rateDecreaseInterval) + NanoSeconds(delta), &RdmaHw::CheckRateDecreaseMlx, this, q);
}

void RdmaHw::RateIncEventTimerMlx(Ptr<RdmaQueuePair> q){
	q->mlx.m_rpTimer = Simulator::Schedule(MicroSeconds(m_rpgTimeReset), &RdmaHw::RateIncEventTimerMlx, this, q);
	RateIncEventMlx(q);
	q->mlx.m_rpTimeStage++;
}
void RdmaHw::RateIncEventMlx(Ptr<RdmaQueuePair> q){
	// check which increase phase: fast recovery, active increase, hyper increase
	if (q->mlx.m_rpTimeStage < m_rpgThreshold){ // fast recovery
		FastRecoveryMlx(q);
	}else if (q->mlx.m_rpTimeStage == m_rpgThreshold){ // active increase
		ActiveIncreaseMlx(q);
	}else { // hyper increase
		HyperIncreaseMlx(q);
	}
}

void RdmaHw::FastRecoveryMlx(Ptr<RdmaQueuePair> q){
	#if PRINT_LOG
	printf("%lu fast recovery: %08x %08x %u %u (%0.3lf %.3lf)->", Simulator::Now().GetTimeStep(), q->sip.Get(), q->dip.Get(), q->sport, q->dport, q->mlx.m_targetRate.GetBitRate() * 1e-9, q->m_rate.GetBitRate() * 1e-9);
	#endif
	q->m_rate = (q->m_rate / 2) + (q->mlx.m_targetRate / 2);
	#if PRINT_LOG
	printf("(%.3lf %.3lf)\n", q->mlx.m_targetRate.GetBitRate() * 1e-9, q->m_rate.GetBitRate() * 1e-9);
	#endif
}
void RdmaHw::ActiveIncreaseMlx(Ptr<RdmaQueuePair> q){
	#if PRINT_LOG
	printf("%lu active inc: %08x %08x %u %u (%0.3lf %.3lf)->", Simulator::Now().GetTimeStep(), q->sip.Get(), q->dip.Get(), q->sport, q->dport, q->mlx.m_targetRate.GetBitRate() * 1e-9, q->m_rate.GetBitRate() * 1e-9);
	#endif
	// get NIC
	uint32_t nic_idx = GetNicIdxOfQp(q);
	Ptr<QbbNetDevice> dev = m_nic[nic_idx].dev;
	// increate rate
	q->mlx.m_targetRate += m_rai;
	if (q->mlx.m_targetRate > dev->GetDataRate())
		q->mlx.m_targetRate = dev->GetDataRate();
	q->m_rate = (q->m_rate / 2) + (q->mlx.m_targetRate / 2);
	#if PRINT_LOG
	printf("(%.3lf %.3lf)\n", q->mlx.m_targetRate.GetBitRate() * 1e-9, q->m_rate.GetBitRate() * 1e-9);
	#endif
}
void RdmaHw::HyperIncreaseMlx(Ptr<RdmaQueuePair> q){
	#if PRINT_LOG
	printf("%lu hyper inc: %08x %08x %u %u (%0.3lf %.3lf)->", Simulator::Now().GetTimeStep(), q->sip.Get(), q->dip.Get(), q->sport, q->dport, q->mlx.m_targetRate.GetBitRate() * 1e-9, q->m_rate.GetBitRate() * 1e-9);
	#endif
	// get NIC
	uint32_t nic_idx = GetNicIdxOfQp(q);
	Ptr<QbbNetDevice> dev = m_nic[nic_idx].dev;
	// increate rate
	q->mlx.m_targetRate += m_rhai;
	if (q->mlx.m_targetRate > dev->GetDataRate())
		q->mlx.m_targetRate = dev->GetDataRate();
	q->m_rate = (q->m_rate / 2) + (q->mlx.m_targetRate / 2);
	#if PRINT_LOG
	printf("(%.3lf %.3lf)\n", q->mlx.m_targetRate.GetBitRate() * 1e-9, q->m_rate.GetBitRate() * 1e-9);
	#endif
}

/***********************
 * High Precision CC
 ***********************/
void RdmaHw::HandleAckHp(Ptr<RdmaQueuePair> qp, Ptr<Packet> p, CustomHeader &ch){
	uint32_t ack_seq = ch.ack.seq;
	// update rate
	if (ack_seq > qp->hp.m_lastUpdateSeq){ // if full RTT feedback is ready, do full update
		UpdateRateHp(qp, p, ch, false);
	}else{ // do fast react
		FastReactHp(qp, p, ch);
	}
}

void RdmaHw::UpdateRateHp(Ptr<RdmaQueuePair> qp, Ptr<Packet> p, CustomHeader &ch, bool fast_react){
	uint32_t next_seq = qp->snd_nxt;
	bool print = !fast_react || true;
	if (qp->hp.m_lastUpdateSeq == 0){ // first RTT
		qp->hp.m_lastUpdateSeq = next_seq;
		// store INT
		IntHeader &ih = ch.ack.ih;
		NS_ASSERT(ih.nhop <= IntHeader::maxHop);
		for (uint32_t i = 0; i < ih.nhop; i++)
			qp->hp.hop[i] = ih.hop[i];
		#if PRINT_LOG
		if (print){
			printf("%lu %s %08x %08x %u %u [%u,%u,%u]", Simulator::Now().GetTimeStep(), fast_react? "fast" : "update", qp->sip.Get(), qp->dip.Get(), qp->sport, qp->dport, qp->hp.m_lastUpdateSeq, ch.ack.seq, next_seq);
			for (uint32_t i = 0; i < ih.nhop; i++)
				printf(" %u %lu %lu", ih.hop[i].GetQlen(), ih.hop[i].GetBytes(), ih.hop[i].GetTime());
			printf("\n");
		}
		#endif
	}else {
		// check packet INT
		IntHeader &ih = ch.ack.ih;
		if (ih.nhop <= IntHeader::maxHop){
			double max_c = 0;
			bool inStable = false;
			#if PRINT_LOG
			if (print)
				printf("%lu %s %08x %08x %u %u [%u,%u,%u]", Simulator::Now().GetTimeStep(), fast_react? "fast" : "update", qp->sip.Get(), qp->dip.Get(), qp->sport, qp->dport, qp->hp.m_lastUpdateSeq, ch.ack.seq, next_seq);
			#endif
			// check each hop
			double U = 0;
			uint64_t dt = 0;
			bool updated[IntHeader::maxHop] = {false}, updated_any = false;
			NS_ASSERT(ih.nhop <= IntHeader::maxHop);
			for (uint32_t i = 0; i < ih.nhop; i++){
				if (m_sampleFeedback){
					if (ih.hop[i].GetQlen() == 0 && fast_react)
						continue;
				}
				updated[i] = updated_any = true;
				#if PRINT_LOG
				if (print)
					printf(" %u(%u) %lu(%lu) %lu(%lu)", ih.hop[i].GetQlen(), qp->hp.hop[i].GetQlen(), ih.hop[i].GetBytes(), qp->hp.hop[i].GetBytes(), ih.hop[i].GetTime(), qp->hp.hop[i].GetTime());
				#endif
				uint64_t tau = ih.hop[i].GetTimeDelta(qp->hp.hop[i]);;
				double duration = tau * 1e-9;
				double txRate = (ih.hop[i].GetBytesDelta(qp->hp.hop[i])) * 8 / duration;
				double u = txRate / ih.hop[i].GetLineRate() + (double)std::min(ih.hop[i].GetQlen(), qp->hp.hop[i].GetQlen()) * qp->m_max_rate.GetBitRate() / ih.hop[i].GetLineRate() /qp->m_win;
				#if PRINT_LOG
				if (print)
					printf(" %.3lf %.3lf", txRate, u);
				#endif
				if (!m_multipleRate){
					// for aggregate (single R)
					if (u > U){
						U = u;
						dt = tau;
					}
				}else {
					// for per hop (per hop R)
					if (tau > qp->m_baseRtt)
						tau = qp->m_baseRtt;
					qp->hp.hopState[i].u = (qp->hp.hopState[i].u * (qp->m_baseRtt - tau) + u * tau) / double(qp->m_baseRtt);
				}
				qp->hp.hop[i] = ih.hop[i];
			}

			DataRate new_rate;
			int32_t new_incStage;
			DataRate new_rate_per_hop[IntHeader::maxHop];
			int32_t new_incStage_per_hop[IntHeader::maxHop];
			if (!m_multipleRate){
				// for aggregate (single R)
				if (updated_any){
					if (dt > qp->m_baseRtt)
						dt = qp->m_baseRtt;
					qp->hp.u = (qp->hp.u * (qp->m_baseRtt - dt) + U * dt) / double(qp->m_baseRtt);
					max_c = qp->hp.u / m_targetUtil;

					if (max_c >= 1 || qp->hp.m_incStage >= m_miThresh){
						new_rate = qp->hp.m_curRate / max_c + m_rai;
						new_incStage = 0;
					}else{
						new_rate = qp->hp.m_curRate + m_rai;
						new_incStage = qp->hp.m_incStage+1;
					}
					if (new_rate < m_minRate)
						new_rate = m_minRate;
					if (new_rate > qp->m_max_rate)
						new_rate = qp->m_max_rate;
					#if PRINT_LOG
					if (print)
						printf(" u=%.6lf U=%.3lf dt=%u max_c=%.3lf", qp->hp.u, U, dt, max_c);
					#endif
					#if PRINT_LOG
					if (print)
						printf(" rate:%.3lf->%.3lf\n", qp->hp.m_curRate.GetBitRate()*1e-9, new_rate.GetBitRate()*1e-9);
					#endif
				}
			}else{
				// for per hop (per hop R)
				new_rate = qp->m_max_rate;
				for (uint32_t i = 0; i < ih.nhop; i++){
					if (updated[i]){
						double c = qp->hp.hopState[i].u / m_targetUtil;
						if (c >= 1 || qp->hp.hopState[i].incStage >= m_miThresh){
							new_rate_per_hop[i] = qp->hp.hopState[i].Rc / c + m_rai;
							new_incStage_per_hop[i] = 0;
						}else{
							new_rate_per_hop[i] = qp->hp.hopState[i].Rc + m_rai;
							new_incStage_per_hop[i] = qp->hp.hopState[i].incStage+1;
						}
						// bound rate
						if (new_rate_per_hop[i] < m_minRate)
							new_rate_per_hop[i] = m_minRate;
						if (new_rate_per_hop[i] > qp->m_max_rate)
							new_rate_per_hop[i] = qp->m_max_rate;
						// find min new_rate
						if (new_rate_per_hop[i] < new_rate)
							new_rate = new_rate_per_hop[i];
						#if PRINT_LOG
						if (print)
							printf(" [%u]u=%.6lf c=%.3lf", i, qp->hp.hopState[i].u, c);
						#endif
						#if PRINT_LOG
						if (print)
							printf(" %.3lf->%.3lf", qp->hp.hopState[i].Rc.GetBitRate()*1e-9, new_rate.GetBitRate()*1e-9);
						#endif
					}else{
						if (qp->hp.hopState[i].Rc < new_rate)
							new_rate = qp->hp.hopState[i].Rc;
					}
				}
				#if PRINT_LOG
				printf("\n");
				#endif
			}
			if (updated_any)
				ChangeRate(qp, new_rate);
			if (!fast_react){
				if (updated_any){
					qp->hp.m_curRate = new_rate;
					qp->hp.m_incStage = new_incStage;
				}
				if (m_multipleRate){
					// for per hop (per hop R)
					for (uint32_t i = 0; i < ih.nhop; i++){
						if (updated[i]){
							qp->hp.hopState[i].Rc = new_rate_per_hop[i];
							qp->hp.hopState[i].incStage = new_incStage_per_hop[i];
						}
					}
				}
			}
		}
		if (!fast_react){
			if (next_seq > qp->hp.m_lastUpdateSeq)
				qp->hp.m_lastUpdateSeq = next_seq; //+ rand() % 2 * m_mtu;
		}
	}
}

void RdmaHw::FastReactHp(Ptr<RdmaQueuePair> qp, Ptr<Packet> p, CustomHeader &ch){
	if (m_fast_react)
		UpdateRateHp(qp, p, ch, true);
}

/**********************
 * TIMELY
 *********************/
void RdmaHw::HandleAckTimely(Ptr<RdmaQueuePair> qp, Ptr<Packet> p, CustomHeader &ch){
	uint32_t ack_seq = ch.ack.seq;
	// update rate
	if (ack_seq > qp->tmly.m_lastUpdateSeq){ // if full RTT feedback is ready, do full update
		UpdateRateTimely(qp, p, ch, false);
	}else{ // do fast react
		FastReactTimely(qp, p, ch);
	}
}
// void RdmaHw::UpdateRateTimely(Ptr<RdmaQueuePair> qp, Ptr<Packet> p, CustomHeader &ch, bool us){
// 	uint32_t next_seq = qp->snd_nxt;
// 	uint64_t rtt = Simulator::Now().GetTimeStep() - ch.ack.ih.ts;
// 	bool print = !us;
// 	if (qp->tmly.m_lastUpdateSeq != 0){ // not first RTT
// 		int64_t new_rtt_diff = (int64_t)rtt - (int64_t)qp->tmly.lastRtt;
// 		double rtt_diff = (1 - m_tmly_alpha) * qp->tmly.rttDiff + m_tmly_alpha * new_rtt_diff;
// 		double gradient = rtt_diff / m_tmly_minRtt;
// 		bool inc = false;
// 		double c = 0;
// 		printf("%lu node:%u rtt:%lu rttDiff:%.0lf gradient:%.3lf rate:%.3lf\n", Simulator::Now().GetTimeStep(), m_node->GetId(), rtt, rtt_diff, gradient, qp->tmly.m_curRate.GetBitRate() * 1e-9);
// 		if (rtt < m_tmly_TLow){
// 			inc = true;
// 		}else if (rtt > m_tmly_THigh){
// 			c = 1 - m_tmly_beta * (1 - (double)m_tmly_THigh / rtt);
// 			inc = false;
// 		}else if (gradient <= 0){
// 			inc = true;
// 		}else{
// 			c = 1 - m_tmly_beta * gradient;
// 			if (c < 0)
// 				c = 0;
// 			inc = false;
// 		}
// 		if (inc){
// 			if (qp->tmly.m_incStage < 5){
// 				qp->m_rate = qp->tmly.m_curRate + m_rai;
// 			}else{
// 				qp->m_rate = qp->tmly.m_curRate + m_rhai;
// 			}
// 			if (qp->m_rate > qp->m_max_rate)
// 				qp->m_rate = qp->m_max_rate;
// 			if (!us){
// 				qp->tmly.m_curRate = qp->m_rate;
// 				qp->tmly.m_incStage++;
// 				qp->tmly.rttDiff = rtt_diff;
// 			}
// 		}else{
// 			qp->m_rate = std::max(m_minRate, qp->tmly.m_curRate * c); 
// 			if (!us){
// 				qp->tmly.m_curRate = qp->m_rate;
// 				qp->tmly.m_incStage = 0;
// 				qp->tmly.rttDiff = rtt_diff;
// 			}
// 		}
// 		#if PRINT_LOG
// 		if (print){
// 			printf(" %c %.3lf\n", inc? '^':'v', qp->m_rate.GetBitRate() * 1e-9);
// 		}
// 		#endif
// 	}
// 	if (!us && next_seq > qp->tmly.m_lastUpdateSeq){
// 		qp->tmly.m_lastUpdateSeq = next_seq;
// 		// update
// 		qp->tmly.lastRtt = rtt;
// 	}
// }
void RdmaHw::UpdateRateTimely(Ptr<RdmaQueuePair> qp, Ptr<Packet> p, CustomHeader &ch, bool us){
	uint32_t next_seq = qp->snd_nxt;
	uint64_t rtt = Simulator::Now().GetTimeStep() - ch.ack.ih.ts;
	bool print = !us;
	double oldrate = qp->tmly.m_curRate.GetBitRate() * 1e-9;
	double gradient = 0;
	double rttnew = (double)(int64_t)rtt/1000;
	int nod = (int)m_node->GetId();
	rtts[nod][0] = rtts[nod][1];
	rtts[nod][1] = rtts[nod][2];
	rtts[nod][2] = (double)(int64_t)rtt;
	double pr = rtt_predict.rtt_p(rtts[nod],&(rtts[nod][3]));
	//printf("node:%d rtt: %.3lf rttp:%.3lf rtts:%.3lf %.3lf %.3lf\n ",nod,(double)(int64_t)rtt,pr,rtts[nod][0],rtts[nod][1],rtts[nod][2]);
	if (qp->tmly.m_lastUpdateSeq != 0){ // not first RTT
		double new_rtt_diff = (double)((int64_t)rtt - (int64_t)m_tmly_TLow);
		//double rtt_diff = (1 - m_tmly_alpha) * qp->tmly.rttDiff + m_tmly_alpha * new_rtt_diff;
		//double rtt_diff = qp->tmly.rttDiff;
		gradient = new_rtt_diff / (double)m_tmly_minRtt;

		////pid_cc and threshold policey
		////1.Fpid(rttdiff) = p*rttdiff + i*sum(rttdiff) + d* df(rttdifff)
		///set param i and d are zero,p = -1/20
		///set newrate = rate*(1+Fpid(rttdiff))
	
		///2.set param i is zero,p = -1/(10*m_tmly_minRtt) ,d = -1/5
		//bool inc = false;//increase
		if (rtt > m_tmly_THigh|| gradient>10){
			gradient = 10;
		}else if (rtt < m_tmly_TLow || gradient<-10){
			gradient = -10;
		}
		
		double c = pids[nod].process(((double)(int64_t)rtt)/1000,pr/1000,nod)+1;
		printf("node:%u w:%.3lf rate:%.3lf new_rtt%.3lf c:%.3lf rttpred:%.3lf rtttarget:%.3lf\n",m_node->GetId(), pids[nod].wi,qp->tmly.m_curRate.GetBitRate() * 1e-9,rttnew,c ,pr,pids[nod].rtttarget);
		printf("rtt:%.3lf %.3lf %.3lf rtts:%.3lf\n",rtts[nod][0],rtts[nod][1],rtts[nod][2],rtts[nod][3]);
		// if (rtt > m_tmly_THigh|| gradient>10){
		// 	c = 0.4;
		// }else if (rtt < m_tmly_TLow || gradient<-10){
		// 	gradient = 1.6;
		// }
		if(c>1.5)c = 1.5;
		else if(c<0.4)c = 0.4;
		qp->m_rate = qp->tmly.m_curRate*c;
		if (qp->m_rate > qp->m_max_rate)
			qp->m_rate = qp->m_max_rate;
		else if(qp->m_rate < m_minRate)
			qp->m_rate = m_minRate;
		
		if (!us){
			qp->tmly.m_curRate = qp->m_rate;
			qp->tmly.m_incStage = 0;
			qp->tmly.rttDiff = gradient;
		}
		qp->tmly.lastRtt = rtt;
		
	}
	if (!us && next_seq > qp->tmly.m_lastUpdateSeq){
		qp->tmly.m_lastUpdateSeq = next_seq;
		// update
		//qp->tmly.lastRtt = rtt;
	}
	//printf("%lu node:%u rtt:%lu rate:%.3lf ratenew:%.3lf,ecn:%d\n", Simulator::Now().GetTimeStep(), m_node->GetId(), rtt, oldrate,qp->tmly.m_curRate.GetBitRate() * 1e-9,ch.GetIpv4EcnBits());
	
}
void RdmaHw::FastReactTimely(Ptr<RdmaQueuePair> qp, Ptr<Packet> p, CustomHeader &ch){
}

/**********************
 * DCTCP
 *********************/
void RdmaHw::HandleAckDctcp(Ptr<RdmaQueuePair> qp, Ptr<Packet> p, CustomHeader &ch){
	uint32_t ack_seq = ch.ack.seq;
	uint8_t cnp = (ch.ack.flags >> qbbHeader::FLAG_CNP) & 1;
	bool new_batch = false;

	// update alpha
	qp->dctcp.m_ecnCnt += (cnp > 0);
	if (ack_seq > qp->dctcp.m_lastUpdateSeq){ // if full RTT feedback is ready, do alpha update
		#if PRINT_LOG
		printf("%lu %s %08x %08x %u %u [%u,%u,%u] %.3lf->", Simulator::Now().GetTimeStep(), "alpha", qp->sip.Get(), qp->dip.Get(), qp->sport, qp->dport, qp->dctcp.m_lastUpdateSeq, ch.ack.seq, qp->snd_nxt, qp->dctcp.m_alpha);
		#endif
		new_batch = true;
		if (qp->dctcp.m_lastUpdateSeq == 0){ // first RTT
			qp->dctcp.m_lastUpdateSeq = qp->snd_nxt;
			qp->dctcp.m_batchSizeOfAlpha = qp->snd_nxt / m_mtu + 1;
		}else {
			double frac = std::min(1.0, double(qp->dctcp.m_ecnCnt) / qp->dctcp.m_batchSizeOfAlpha);
			qp->dctcp.m_alpha = (1 - m_g) * qp->dctcp.m_alpha + m_g * frac;
			qp->dctcp.m_lastUpdateSeq = qp->snd_nxt;
			qp->dctcp.m_ecnCnt = 0;
			qp->dctcp.m_batchSizeOfAlpha = (qp->snd_nxt - ack_seq) / m_mtu + 1;
			#if PRINT_LOG
			printf("%.3lf F:%.3lf", qp->dctcp.m_alpha, frac);
			#endif
		}
		#if PRINT_LOG
		printf("\n");
		#endif
	}

	// check cwr exit
	if (qp->dctcp.m_caState == 1){
		if (ack_seq > qp->dctcp.m_highSeq)
			qp->dctcp.m_caState = 0;
	}

	// check if need to reduce rate: ECN and not in CWR
	if (cnp && qp->dctcp.m_caState == 0){
		#if PRINT_LOG
		printf("%lu %s %08x %08x %u %u %.3lf->", Simulator::Now().GetTimeStep(), "rate", qp->sip.Get(), qp->dip.Get(), qp->sport, qp->dport, qp->m_rate.GetBitRate()*1e-9);
		#endif
		qp->m_rate = std::max(m_minRate, qp->m_rate * (1 - qp->dctcp.m_alpha / 2));
		#if PRINT_LOG
		printf("%.3lf\n", qp->m_rate.GetBitRate() * 1e-9);
		#endif
		qp->dctcp.m_caState = 1;
		qp->dctcp.m_highSeq = qp->snd_nxt;
	}

	// additive inc
	if (qp->dctcp.m_caState == 0 && new_batch)
		qp->m_rate = std::min(qp->m_max_rate, qp->m_rate + m_dctcp_rai);
}

/*********************
 * HPCC-PINT
 ********************/
void RdmaHw::SetPintSmplThresh(double p){
       pint_smpl_thresh = (uint32_t)(65536 * p);
}
void RdmaHw::HandleAckHpPint(Ptr<RdmaQueuePair> qp, Ptr<Packet> p, CustomHeader &ch){
       uint32_t ack_seq = ch.ack.seq;
       if (rand() % 65536 >= pint_smpl_thresh)
               return;
       // update rate
       if (ack_seq > qp->hpccPint.m_lastUpdateSeq){ // if full RTT feedback is ready, do full update
               UpdateRateHpPint(qp, p, ch, false);
       }else{ // do fast react
               UpdateRateHpPint(qp, p, ch, true);
       }
}

void RdmaHw::UpdateRateHpPint(Ptr<RdmaQueuePair> qp, Ptr<Packet> p, CustomHeader &ch, bool fast_react){
       uint32_t next_seq = qp->snd_nxt;
       if (qp->hpccPint.m_lastUpdateSeq == 0){ // first RTT
               qp->hpccPint.m_lastUpdateSeq = next_seq;
       }else {
               // check packet INT
               IntHeader &ih = ch.ack.ih;
               double U = Pint::decode_u(ih.GetPower());

               DataRate new_rate;
               int32_t new_incStage;
               double max_c = U / m_targetUtil;

               if (max_c >= 1 || qp->hpccPint.m_incStage >= m_miThresh){
                       new_rate = qp->hpccPint.m_curRate / max_c + m_rai;
                       new_incStage = 0;
               }else{
                       new_rate = qp->hpccPint.m_curRate + m_rai;
                       new_incStage = qp->hpccPint.m_incStage+1;
               }
               if (new_rate < m_minRate)
                       new_rate = m_minRate;
               if (new_rate > qp->m_max_rate)
                       new_rate = qp->m_max_rate;
               ChangeRate(qp, new_rate);
               if (!fast_react){
                       qp->hpccPint.m_curRate = new_rate;
                       qp->hpccPint.m_incStage = new_incStage;
               }
               if (!fast_react){
                       if (next_seq > qp->hpccPint.m_lastUpdateSeq)
                               qp->hpccPint.m_lastUpdateSeq = next_seq; //+ rand() % 2 * m_mtu;
               }
       }
}

}
